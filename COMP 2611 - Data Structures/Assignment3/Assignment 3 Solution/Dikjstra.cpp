#include <iostream>
#include "DataTypes.h"
#include "Graph.h"
#include "Dijkstra.h"
#include "Heap.h"
#include "PriorityQueue.h"

   using namespace std;
   
// This is the initSingleSource function from Page 249 of the text.
//  A special table, shortestPaths (of type Node) keeps track of the
//  table shown on Pages 246-248. All the vertices, except the source
//  have an initial cost of INFINITY. The source has an initial cost
//  of 0. The predecessor of all the vertices is 0, representing nil.

void initSingleSource (Graph * graph, Node shortestPaths[], int source) {
	int v, numVertices;
		
	numVertices = graph->numVertices;
		
	for (int v = 1; v <= numVertices; v = v + 1) {
		shortestPaths[v].vertex = v;
		shortestPaths[v].predecessor = 0;
		shortestPaths[v].cost = INFINITY;
	}
	
	shortestPaths[source].cost = 0;
}


// This function inserts all the Nodes from shortestPaths into the min
//  priority queue.

void initMinPriorityQueue (Node shortestPaths[], Node priorityQueue[], int numQueue) {

	int v, heapSize;
		
	heapSize = 0;
		
	for (int v = 1; v <= numQueue; v = v + 1) {
		heapSize = minHeapInsert(priorityQueue, heapSize, shortestPaths[v]);
	}
	
}
		

// This function checks to see if there is a cheaper cost to the destination,
//  dest, by going through the origin, given the weight of the new edge between
//  origin and dest.If so, it updates the cost of going to the destination, 
//  via the origin. This function is typically called "relax".

void relax (Node shortestPaths[], int origin, int dest, int weight) {
        	
	if (shortestPaths[dest].cost > shortestPaths[origin].cost + weight) {
		shortestPaths[dest].cost = shortestPaths[origin].cost + weight;
		shortestPaths[dest].predecessor = origin;
	}
}


void displayResultNodes (Graph * graph, Node A[]) {
	
	int i;
	
	cout << "Vertex \t\tPredecessor \tCost to Vertex" << endl;
	cout << "====== \t\t=========== \t==============" << endl;
	for (i=1; i<=graph->numVertices; i = i + 1) {
		cout << graph->vertices[A[i].vertex].ID << "\t\t";
		cout << A[i].predecessor << "\t\t";
		cout << A[i].cost << endl;
	}
	
	cout << endl;
}


void displayDijkstraTable (Graph * graph, Node A[], int source) {
	
	int i, v, lengthA;
	
	lengthA = graph->numVertices;
	
	cout << "This is the shortest paths table generated by Dijkstra's Algorithm." << endl;
	cout << "The starting vertex is " << graph->vertices[source].ID << ":" << endl << endl;
	

	cout << "Vertex\t\t";
	for (i=1; i<=lengthA; i = i + 1) {
		v = A[i].vertex;
		cout << graph->vertices[v].ID << "\t";
	}
	cout << endl;
	
	cout << "Predecessor\t";
	for (i=1; i<=lengthA; i = i + 1) {
		v = A[i].predecessor;
		if (v == 0) 
			cout << "NIL\t";
		else
			cout << graph->vertices[v].ID << "\t";
	}
	cout << endl;

	cout << "Cost\t\t";
	for (i=1; i<=lengthA; i = i + 1) {
		if (A[i].cost == INFINITY)
			cout << "INF\t";
		else
			cout << A[i].cost << "\t";
	}
	
	cout << endl << endl;
}


// This is the implementation of Dijkstra's Algorithm. The table of shortest
//  paths is accepted as a parameter. When the algorithm terminates, the
//  table of shortest paths has the shortest path from the source vertex to
//  every other vertex.

void dijkstra (Graph * graph, Node shortestPaths[], int source) {
	
	Node priorityQueue [MAX_VERTICES];
	Node minimum;
	int minVertex;
	
	int numQueue;
	int dest, weight;
	
	initSingleSource (graph, shortestPaths, source);

//	cout << "initSingleSource complete ..." << endl << endl;

//	cout << "Nodes for Dijkstra's result table are as follows:" << endl << endl;
	
//	displayResultNodes(graph, shortestPaths); 			// check if initial table for results is OK

	numQueue = graph->numVertices;
	initMinPriorityQueue (shortestPaths, priorityQueue, numQueue);

//	cout << endl;
//	cout << "initialisation of Min Priority Queue complete ..." << endl << endl;
	
	while (!isEmptyHeap(priorityQueue, numQueue)) {
		minimum = heapExtractMin (priorityQueue, numQueue);		
		numQueue = numQueue - 1;
		minVertex = minimum.vertex;
		
		if (shortestPaths[minVertex].cost == INFINITY)
			continue;								// if cost is INFINITY, don't process vertex
		
		Vertex vertex = graph->vertices[minVertex];	// go to array of vertices
		
		Edge * edge = vertex.firstEdge;				// find first edge
		
		while (edge != NULL) {
			dest = edge->child;						// find destination node
			weight = edge->weight;					// find cost to get to destination node
			relax (shortestPaths, minVertex, dest, weight);
													// check if shorter path to destination node is found
			int location = searchHeap (priorityQueue, numQueue, dest);
													// find location in priority queue of destination node
			heapDecreasePriority (priorityQueue, numQueue, location, shortestPaths[dest].cost);
													// increase priority of destination node
			edge = edge->nextEdge;					// go to next edge
		}
		
//		cout << "Finished processing Vertex " << minVertex << endl;
	}	
	
//	cout << endl;
//	cout << "Dijkstra's Algorithm successfully executed." << endl << endl;	
}


// This function prints the shortest path from the source vertex 
//  to the given vertex. It uses the shortestPaths table created by
//  Dijkstra's Algorithm. The function uses recursion since the
//  information in the table must be traversed in a backward manner.

void printPath (Graph * graph, Node shortestPaths[], int vertex) {
	
	int pred;
		
	if (vertex != 0) {
		pred = shortestPaths[vertex].predecessor;
		printPath (graph, shortestPaths, pred);
		if (pred != 0) {
			cout << " -> ";
		}
		cout << graph->vertices[vertex].ID;
	}

}


// This function prints the shortest path from the source vertex 
//  to all the other vertices in the graph. It uses the shortestPaths 
//  table created by Dijkstra's Algorithm. The output closely
//  resembles the output given on Page 248 of the text.

void printPathsAndCosts (Graph * graph, Node shortestPaths[], int source)  {
	
	int numVertices, v;
	
//	displayDijkstraTable (graph, shortestPaths, source);
	
	cout << "The following are the shortest paths from Vertex ";
	cout << graph->vertices[source].ID << ":" << endl << endl;	
	
	numVertices = graph->numVertices;

	for	(int v=1; v<=numVertices; v=v+1) {
		if (v != source) {
			string destID = graph->vertices[v].ID;
//			cout << "Cost to " << destID << ": ";
			cout << "Path to " << destID << ": ";
			if (shortestPaths[v].cost == INT_MAX)
				cout << "Does not exist." << endl;
			else {
//				cout << shortestPaths[v].cost<<", ";
				printPath(graph, shortestPaths, v);
				cout << endl;
			}
		}
	}
	
	cout << endl;
}
